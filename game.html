<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>0110-The Institute (Chapter 1)</title>
    <style>
      :root {
        --primary: #00f3ff;
        --combat: #ff3333;
        --terminal-text: #00ff00;
        --terminal-border: #00ff00;
        --passive: #888888;
        --bg-glass: rgba(5, 10, 15, 0.95);
        --margin: 30px;
        --obj-bg: rgba(0, 20, 20, 0.9);
        --obj-border: #004444;
      }

      body {
        margin: 0;
        overflow: hidden;
        background-color: #000000;
        font-family: "Courier New", Courier, monospace;
        color: white;
        user-select: none;
      }
      canvas {
        display: block;
      }

      /* DYNAMIC THEME SWITCHING */
      body.mode-roam {
        --hud-color: var(--primary);
        --terminal-text: #00ff00;
        --terminal-border: #004400;
      }
      body.mode-combat {
        --hud-color: var(--combat);
        --terminal-text: #ff3333;
        --terminal-border: #440000;
      }

      /* UI LAYOUT */
      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        opacity: 0;
        transition: opacity 2s;
      }
      #ui-layer.active {
        opacity: 1;
      }
      .hud-element {
        pointer-events: auto;
        position: absolute;
      }
      .hidden {
        display: none !important;
      }

      /* PAUSE OVERLAY */
      #pause-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 900;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s;
        backdrop-filter: blur(2px);
      }
      #pause-overlay.visible {
        opacity: 1;
        pointer-events: auto;
      }
      #pause-text {
        font-size: 40px;
        color: #fff;
        letter-spacing: 10px;
        text-shadow: 0 0 20px #fff;
      }

      /* CINEMATICS */
      #cinematic-overlay,
      #story-overlay,
      #fade-overlay,
      #overlay-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        pointer-events: none;
        z-index: 9999;
      }
      #cinematic-overlay {
        background: black;
        transition: opacity 2s;
      }
      #story-overlay {
        background: black;
        opacity: 0;
        transition: opacity 2s;
      }
      #fade-overlay {
        background: black;
        opacity: 0;
        transition: opacity 3s;
      }
      #overlay-screen {
        background: black;
        opacity: 0;
        transition: opacity 1s;
      }

      .title-text { 
    font-size: 50px; 
    font-weight: bold; 
    letter-spacing: 15px; 
    text-shadow: 0 0 30px white; 
    text-align: center;
    opacity: 0; /* Start hidden */
    transition: opacity 2s ease-in-out; /* Smooth fade */
}

.subtitle-text { 
    font-size: 25px; 
    letter-spacing: 8px; 
    color: var(--primary); 
    margin-top: 20px; 
    text-align: center;
    opacity: 0; /* Start hidden */
    transition: opacity 2s ease-in-out; /* Smooth fade */
}

      /* STORY TEXT STYLES */
      #story-content {
        max-width: 600px;
        text-align: center;
        color: #ddd;
      }
      #story-content h2 {
        font-size: 32px;
        color: var(--primary);
        margin-bottom: 20px;
        letter-spacing: 5px;
      }
      #story-content p {
        font-size: 16px;
        line-height: 1.6;
        letter-spacing: 1px;
      }

      #overlay-text {
        font-size: 20px;
        color: var(--primary);
        letter-spacing: 5px;
      }

      /* HUD ELEMENTS */
      #profile-indicator {
        position: absolute;
        top: var(--margin);
        left: 50%;
        transform: translateX(-50%);
        border: 1px solid var(--hud-color);
        background: rgba(0, 0, 0, 0.8);
        padding: 5px 20px;
        font-weight: bold;
        color: var(--hud-color);
        text-shadow: 0 0 10px var(--hud-color);
        letter-spacing: 2px;
        transition: 0.3s;
      }

      #hud-top-left {
        top: var(--margin);
        left: var(--margin);
        width: 350px;
        text-shadow: 0 1px 2px black;
      }
      .log-entry {
        font-size: 14px;
        margin-bottom: 4px;
        opacity: 0.6;
        transition: opacity 0.5s;
        color: var(--hud-color);
      }
      .log-entry.new {
        opacity: 1;
        font-weight: bold;
        text-shadow: 0 0 8px var(--hud-color);
      }
      .log-entry.error {
        color: #ff3333;
        opacity: 1;
        text-shadow: 0 0 8px #ff3333;
      }
      .log-entry.safe {
        color: #00ffaa;
        opacity: 1;
        text-shadow: 0 0 10px #00ffaa;
      }
      #coords-display {
        margin-top: 10px;
        font-size: 13px;
        color: #888;
        letter-spacing: 1px;
      }

      #hud-top-right {
        top: var(--margin);
        right: var(--margin);
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        z-index: 1000;
      }
      #menu-icon {
        font-size: 24px;
        color: var(--primary);
        cursor: pointer;
        padding: 5px;
        background: rgba(0, 0, 0, 0.5);
        transition: 0.2s;
        border: 1px solid transparent;
      }
      #menu-icon:hover {
        border-color: var(--primary);
      }
      #menu-dropdown {
        display: none;
        margin-top: 10px;
        background: var(--bg-glass);
        border: 1px solid var(--primary);
        min-width: 140px;
      }
      #menu-dropdown.show {
        display: block;
      }
      .menu-item {
        padding: 10px;
        font-size: 12px;
        color: #ccc;
        cursor: pointer;
        border-bottom: 1px solid #333;
      }
      .menu-item:hover {
        background: rgba(0, 243, 255, 0.1);
        color: white;
      }

      /* OBJECTIVE MODULE */
      #hud-bottom-left {
        bottom: var(--margin);
        left: var(--margin);
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      #objective-wrapper {
        width: 250px;
        background: var(--obj-bg);
        border: 1px solid var(--obj-border);
        border-radius: 4px;
        overflow: hidden;
        transition: height 0.3s ease, border-color 0.3s, box-shadow 0.3s;
        height: 38px;
        margin-bottom: 5px;
      }
      #objective-wrapper.expanded {
        height: auto;
        min-height: 120px;
        border-color: var(--primary);
        box-shadow: 0 0 10px rgba(0, 243, 255, 0.1);
      }
      @keyframes box-pulse {
        0% {
          border-color: var(--obj-border);
        }
        50% {
          border-color: #fff;
          box-shadow: 0 0 15px #fff;
        }
        100% {
          border-color: var(--obj-border);
        }
      }
      .pulse-anim {
        animation: box-pulse 0.5s ease-in-out;
      }
      .obj-header {
        height: 38px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 10px;
        font-size: 14px;
        font-weight: bold;
        background: rgba(0, 0, 0, 0.3);
        color: #fff;
        cursor: default;
      }
      .obj-indicator {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: #444;
      }
      .obj-indicator.active {
        background: var(--primary);
        box-shadow: 0 0 5px var(--primary);
      }
      .obj-content {
        padding: 10px;
        border-top: 1px solid #333;
      }
      .obj-title {
        color: var(--primary);
        font-size: 14px;
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }
      .task-list {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .task-item {
        font-size: 12px;
        color: #888;
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .task-item.done {
        color: #444;
        text-decoration: line-through;
      }
      .task-checkbox {
        color: #444;
        font-weight: bold;
      }
      .task-item.done .task-checkbox {
        color: var(--primary);
      }
      .obj-tip {
        margin-top: 10px;
        font-size: 10px;
        color: #555;
        font-style: italic;
        border-top: 1px solid #222;
        padding-top: 5px;
      }

      #data-bank {
        font-size: 14px;
        color: var(--hud-color);
        font-weight: bold;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px 10px;
        border-left: 3px solid var(--hud-color);
        transition: 0.3s;
      }
      #minimap-container {
        width: 140px;
        height: 140px;
        border-radius: 50%;
        border: 2px solid #333;
        background: #000;
        overflow: hidden;
        position: relative;
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.8);
      }
      #minimap-canvas {
        width: 100%;
        height: 100%;
        opacity: 0.9;
      }
      #minimap-border {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        border: 1px solid var(--hud-color);
        box-shadow: inset 0 0 10px var(--hud-color);
        pointer-events: none;
        transition: 0.3s;
      }

      #hud-bottom-center {
        bottom: var(--margin);
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 500px;
      }
      .stats-row {
        display: flex;
        gap: 15px;
        width: 100%;
        margin-bottom: 12px;
      }
      .bar-wrapper {
        flex: 1;
      }
      .bar-container {
        height: 6px;
        background: #111;
        border: 1px solid #444;
        position: relative;
      }
      #bar-health {
        height: 100%;
        width: 100%;
        transition: width 0.2s, background 0.3s;
      }
      body.mode-roam #bar-health {
        background: var(--passive);
      }
      body.mode-combat #bar-health {
        background: var(--combat);
        box-shadow: 0 0 8px var(--combat);
      }
      #shield-label {
        position: absolute;
        top: -15px;
        right: 0;
        font-size: 9px;
        color: #00ffaa;
        font-weight: bold;
        letter-spacing: 1px;
      }
      .light-display {
        width: 100%;
        text-align: right;
        font-size: 10px;
        color: #ccc;
        margin-top: 2px;
      }
      #light-val {
        color: var(--primary);
        font-weight: bold;
      }
      .bar-label {
        font-size: 10px;
        margin-bottom: 4px;
        display: block;
        color: #aaa;
      }

      #hotbar {
        display: flex;
        gap: 5px;
        transition: opacity 0.3s;
        width: 100%;
      }
      .slot {
        flex: 1;
        height: 45px;
        background: rgba(20, 20, 20, 0.6);
        border: 1px solid #444;
        color: #666;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 10px;
        position: relative;
      }
      .slot-cmd {
        color: var(--primary);
        font-size: 9px;
        padding: 2px;
        position: absolute;
        bottom: 2px;
        width: 100%;
        text-align: center;
        white-space: nowrap;
        text-overflow: ellipsis;
      }

      #hud-bottom-right {
        bottom: var(--margin);
        right: var(--margin);
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        z-index: 100;
      }
      #tablet-icon {
        width: 50px;
        height: 50px;
        background: var(--bg-glass);
        border: 1px solid var(--hud-color);
        border-radius: 4px;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        color: var(--hud-color);
        font-size: 20px;
        z-index: 101;
        transition: 0.3s;
      }
      #tablet-icon:hover {
        text-shadow: 0 0 10px var(--hud-color);
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      }
      /* TERMINAL ANIMATION UPDATE */
      #terminal-wrapper {
        position: absolute; 
        bottom: 60px; 
        right: 0;
        
        /* Initial State: Collapsed to a point/line */
        width: 0;
        height: 0; 
        opacity: 0;
        
        background: rgba(5, 15, 5, 0.98); 
        border: 1px solid var(--terminal-border);
        border-radius: 6px; 
        display: flex; 
        flex-direction: column;
        
        /* Anchor to bottom-right corner */
        transform-origin: bottom right; 
        overflow: hidden; /* Essential to hide content during line animation */
        box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);

        /* CLOSING SEQUENCE: Height collapses -> Width collapses -> Fade out */
        transition: 
            opacity 0.1s linear 0.6s,               /* 3. Disappear after collapse */
            height 0.3s cubic-bezier(0.2, 0.8, 0.2, 1) 0s,   /* 1. Collapse Height first */
            width 0.3s cubic-bezier(0.2, 0.8, 0.2, 1) 0.3s;  /* 2. Collapse Width (to line) */
      }

      #terminal-wrapper.open {
        /* Open State Dimensions */
        width: clamp(200px, 30vw, 400px);
        height: clamp(300px, 40vh, 600px);
        opacity: 1;

        /* OPENING SEQUENCE: Fade in -> Width expands (Line) -> Height expands */
        transition: 
            opacity 0.1s linear 0s,                 /* 1. Appear instantly */
            width 0.3s cubic-bezier(0.2, 0.8, 0.2, 1) 0s,    /* 2. Draw Line (Width) */
            height 0.3s cubic-bezier(0.2, 0.8, 0.2, 1) 0.3s; /* 3. Expand Box (Height) */
      }
      .term-header {
        background: #000;
        padding: 8px 12px;
        font-size: 11px;
        color: var(--terminal-text);
        display: flex;
        justify-content: space-between;
        border-bottom: 1px solid #222;
        letter-spacing: 1px;
      }
      #term-output {
        flex-grow: 1;
        padding: 15px;
        overflow-y: auto;
        font-family: "Consolas", monospace;
        font-size: 12px;
        color: var(--terminal-text);
        line-height: 1.5;
        scrollbar-width: none;
      }
      #term-output::-webkit-scrollbar {
        display: none;
      }
      #term-input-line {
        display: flex;
        padding: 12px;
        background: #000;
        border-top: 1px solid #222;
      }
      #term-input {
        background: transparent;
        border: none;
        color: var(--terminal-text);
        font-family: "Consolas", monospace;
        font-size: 13px;
        flex-grow: 1;
        outline: none;
      }
      .term-msg {
        margin-bottom: 6px;
      }
      .term-cmd {
        color: #fff;
        opacity: 0.7;
      }
      .term-err {
        color: #ff3333;
      }
      .term-suc {
        color: #00ffaa;
      }
    </style>
  </head>
  <body class="mode-roam">
    <div id="fade-overlay"></div>

    <div id="cinematic-overlay">
      <div id="intro-title" class="title-text">ENTERING</div>
      <div id="intro-sub" class="subtitle-text">"null"</div>
      <div id="intro-sub" class="subtitle-text" style="font-size: 14px; color: #888;">Version  1.01</div>
    </div>

    <div id="story-overlay">
      <div id="story-content">
        <h2>1. The Viod</h2>
        <p>
          Will found himself in a dark, empty space, with light emitting from within him. Is he code? Why is he the source of light? He questioned himself.<br><br>

He soon realized this world is a coded reality, and to survive, he must understand its language. In the void, he felt lost, alone, and uncertain.<br><br>

But something else was here, hidden in the darkness, something even the system could not recognize. Now he must move forward, searching for his friend and a way out.<br><br>

Can he survive the darkness? Can he find his friend? Can he escape the void?<br><br>

The journey begins now.<br><br>

Read the full story on <a href="story.html" target="_blank" style="color: var(--primary); text-decoration: underline">0110-game-docs</a>. Thanks for playing the demo.

        </p>
        <p style="color: var(--primary); text-align: center;">A Samir C Production</p>
        <p style="font-size: 14px; color: #888; text-align: center;">Version  1.01</p>
      </div>
    </div>

    <div id="overlay-screen">
      <div id="overlay-text">SourceCode decompiled</div>
    </div>

    <div id="pause-overlay">
      <div id="pause-text">PAUSED</div>
    </div>

    <div id="ui-layer">
      <div id="profile-indicator" class="hidden">PROFILE: ROAMING</div>
      <div id="hud-top-left" class="hud-element">
        <div id="system-log"></div>
        <div id="coords-display">Location: [0, 0]</div>
      </div>
      <div id="hud-top-right" class="hud-element">
        <div id="menu-icon" onclick="UISystem.toggleMenu()">â˜°</div>
        <div id="menu-dropdown">
          <div class="menu-item" onclick="SaveSystem.save()">SAVE GAME</div>
          <div class="menu-item" onclick="SaveSystem.reboot()">
            REBOOT SYSTEM
          </div>
          <div class="menu-item" id="btn-bgm-toggle" onclick="AudioSystem.toggleBGM()">MUTE BGM</div>
        </div>
      </div>
      <div id="hud-bottom-left" class="hud-element">
        <div id="objective-wrapper">
          <div class="obj-header">
            <span id="obj-summary">OBJ: INITIALIZE</span>
            <div class="obj-indicator" id="obj-pulse-dot"></div>
          </div>
          <div class="obj-content">
            <div class="obj-title" id="obj-phase-title">PHASE 1: PREP</div>
            <div class="task-list" id="obj-task-list"></div>
            <div class="obj-tip">Press 'Q' to Toggle. Move to Close.</div>
          </div>
        </div>
        <div id="data-bank">DATA: 0 MB</div>
        <div id="minimap-container">
          <canvas id="minimap-canvas" width="140" height="140"></canvas>
          <div id="minimap-border"></div>
        </div>
      </div>
      <div id="hud-bottom-center" class="hud-element">
        <div class="stats-row">
          <div class="bar-wrapper">
            <span class="bar-label">INTEGRITY</span>
            <div class="bar-container">
              <div id="bar-health"></div>
              <span id="shield-label" class="hidden">[SHIELD ACTIVE]</span>
            </div>
          </div>
          <div class="bar-wrapper">
            <span class="bar-label">-----</span>
            <div class="light-display">
              LUMENS: <span id="light-val">300</span>
            </div>
          </div>
        </div>
        <div id="hotbar">
          <div class="slot" id="slot-1-box">
            <span>1</span>
            <div class="slot-cmd" id="slot-1"></div>
          </div>
          <div class="slot" id="slot-2-box">
            <span>2</span>
            <div class="slot-cmd" id="slot-2"></div>
          </div>
          <div class="slot" id="slot-3-box">
            <span>3</span>
            <div class="slot-cmd" id="slot-3"></div>
          </div>
          <div class="slot" id="slot-4-box">
            <span>4</span>
            <div class="slot-cmd" id="slot-4"></div>
          </div>
          <div class="slot" id="slot-5-box">
            <span>5</span>
            <div class="slot-cmd" id="slot-5"></div>
          </div>
        </div>
      </div>
      <div id="hud-bottom-right" class="hud-element">
        <div id="terminal-wrapper">
          <div class="term-header">
            <span>ROOT // USER: WilliamHayes</span>
            <span>v1.0.4</span>
          </div>
          <div id="term-output"></div>
          <div id="term-input-line">
            <span style="color: var(--terminal-text); margin-right: 10px"
              >></span
            ><input type="text" id="term-input" autocomplete="off" />
          </div>
        </div>
        <div id="tablet-icon" onclick="TerminalSystem.toggle()">&lt;/&gt;</div>
      </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
      const Config = {
        gridSize: 60,
        chunkSize: 2000,
        renderDistance: 1,
        baseLightRadius: 300,
        maxLightLevel: 2.0,
        safeZoneRadius: 300,
        colors: {
          grid: "#222",
          wall: "#fff",
          fragment: "#00f3ff",
          enemy: "#ff3333",
          safe: "#00ffaa",
        },
        player: { maxHealth: 100, accel: 0.15, friction: 0.96, maxSpeed: 4.0 },
        combat: {
          bulletSpeed: 8,
          bulletCost: 2,
          baseEnemyHP: 3,
          baseEnemyDmg: 10,
        },
        audio: {
          // BGM PLAYLIST: Add your music file paths here
          bgm: ["bgm1.mp3", "bgm2.mp3", "bgm3.mp3"],

          // SFX MAPPING: Add your sound effect file paths here
          sfx: {
            term_open: "term.mp3",
            term_close: "term.mp3",
            term_success: "sfx/term_success.mp3",
            obj_toggle: "obj.mp3",
            obj_update: "obj2.mp3",
            log: "",
            intro_hit: "on2.wav", // Sound for "ENTERING NULL"
            story_ambience: "", // Sound for Story text
          },
        },
      };

      // --- AUDIO SYSTEM (FILE BASED) ---
      const AudioSystem = {
        bgmTrack: null,
        currentTrackIndex: 0,
        active: false,
        muted: false, // New State

        init: () => {
          if (AudioSystem.active) return;
          AudioSystem.active = true;
          AudioSystem.playNextBGM();
        },

        playNextBGM: () => {
          if (!Config.audio.bgm || Config.audio.bgm.length === 0) return;
          
          if (AudioSystem.bgmTrack) {
            AudioSystem.bgmTrack.pause();
            AudioSystem.bgmTrack = null;
          }

          const src = Config.audio.bgm[AudioSystem.currentTrackIndex];
          if(!src) return;

          AudioSystem.bgmTrack = new Audio(src);
          AudioSystem.bgmTrack.volume = 0.3;
          
          // Respect mute state on new track load
          if(AudioSystem.muted) AudioSystem.bgmTrack.muted = true;

          AudioSystem.bgmTrack.play().catch(e => console.log("Waiting for interaction..."));
          
          AudioSystem.bgmTrack.addEventListener('ended', () => {
            AudioSystem.currentTrackIndex = (AudioSystem.currentTrackIndex + 1) % Config.audio.bgm.length;
            AudioSystem.playNextBGM();
          });
        },

        // NEW FUNCTION: Toggle Mute
        toggleBGM: () => {
            AudioSystem.muted = !AudioSystem.muted;
            if(AudioSystem.bgmTrack) {
                AudioSystem.bgmTrack.muted = AudioSystem.muted;
            }
            
            // Update Menu Text
            const btn = document.getElementById('btn-bgm-toggle');
            if(btn) btn.innerText = AudioSystem.muted ? "UNMUTE BGM" : "MUTE BGM";
            
            // Optional: Close menu after click for cleaner UX, or keep open
            // UISystem.toggleMenu(); 
        },

        playSFX: (key) => {
          if (!Config.audio.sfx[key]) return;
          const sfx = new Audio(Config.audio.sfx[key]);
          sfx.volume = 0.5;
          sfx.play().catch(e => {}); 
        }
      };

      const CommandBank = {
        "sys.scan": {
          cost: 50,
          desc: "Reveal Loot",
          req: null,
          action: "scan",
        },
        "sys.lumos": {
          cost: 50,
          desc: "Upgrade Light",
          req: null,
          action: "light",
        },
        "sys.compile": {
          cost: 50,
          desc: "Unlock Weapon",
          req: "story",
          action: "combat",
        },
        "sys.cloak": {
          cost: 20,
          desc: "Invisibility (10s)",
          req: "combat",
          action: "cloak",
        },
        "exe.repair": {
          cost: 100,
          desc: "Restore 50 HP",
          req: "combat",
          action: "heal",
        },
        "sys.speed": {
          cost: 80,
          desc: "Boost Velocity",
          req: "light_2",
          limit: 2,
          action: "speed",
        },
        "sys.fire": {
          cost: 60,
          desc: "Boost Fire Rate",
          req: "combat",
          limit: 3,
          action: "firerate",
        },
        "sys.protect": {
          cost: 120,
          desc: "Shield Layer",
          req: "combat",
          limit: 1,
          action: "shield",
        },
        "sys.unbind": {
          cost: 0,
          desc: "Clear Hotkey",
          req: null,
          action: "unbind",
        },
      };

      const State = {
        player: {
          x: 0,
          y: 0,
          vx: 0,
          vy: 0,
          size: 10,
          health: 100,
          shield: 0,
          data: 0,
          lightLevel: 1.0,
          mode: "roam",
          combatUnlocked: false,
          cloaked: false,
          cloakTimer: 0,
          isTerminalOpen: false,
          scanActive: false,
          scanTimer: 0,
          isDead: false,
          stats: { speedLevel: 0, fireRateLevel: 0 },
        },
        game: {
          killCount: 0,
          safeHaven: null,
          safeTimer: 0,
          paused: false,
          survivalTimer: 0,
        },
        world: {
          structures: [],
          fragments: [],
          enemies: [],
          projectiles: [],
          visitedChunks: new Set(),
        },
        hotbar: { 1: "sys.scan", 2: null, 3: null, 4: null, 5: null },
        input: { keys: { w: false, a: false, s: false, d: false } },
      };

      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const miniCanvas = document.getElementById("minimap-canvas");
      const miniCtx = miniCanvas.getContext("2d");

      const Utils = {
        wait: (ms) => new Promise((r) => setTimeout(r, ms)),
        dist: (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2),
        checkRectCollide: (x, y, rect) => {
          return (
            x > rect.x - 10 &&
            x < rect.x + rect.w + 10 &&
            y > rect.y - 10 &&
            y < rect.y + rect.h + 10
          );
        },
        rayCast: (x1, y1, x2, y2) => {
          for (let s of State.world.structures) {
            if (Math.abs(s.x + s.w / 2 - (x1 + x2) / 2) > 1000) continue;
            let minX = Math.min(x1, x2),
              maxX = Math.max(x1, x2),
              minY = Math.min(y1, y2),
              maxY = Math.max(y1, y2);
            if (
              maxX < s.x ||
              minX > s.x + s.w ||
              maxY < s.y ||
              minY > s.y + s.h
            )
              continue;
            return { hit: true };
          }
          return { hit: false };
        },
      };

      const SaveSystem = {
        save: () => {
          const saveData = {
            player: State.player,
            hotbar: State.hotbar,
            kills: State.game.killCount,
            objPhase: ObjectiveSystem.currentPhaseIndex,
          };
          localStorage.setItem("0110_save_v2", JSON.stringify(saveData));
          TerminalSystem.log("SYSTEM SAVED. STATE PRESERVED.", "safe");
          UISystem.toggleMenu();
        },
        load: () => {
          const raw = localStorage.getItem("0110_save_v2");
          if (raw) {
            const data = JSON.parse(raw);
            State.player = { ...State.player, ...data.player };
            State.hotbar = data.hotbar;
            State.game.killCount = data.kills;
            ObjectiveSystem.currentPhaseIndex = data.objPhase || 0;
            State.player.vx = 0;
            State.player.vy = 0;
            State.player.isTerminalOpen = false;
            State.game.paused = false;
            State.world.structures = [];
            State.world.fragments = [];
            State.world.enemies = [];
            State.world.visitedChunks.clear();
            TerminalSystem.updateHotbar();
            ObjectiveSystem.render();
            return true;
          }
          return false;
        },
        reboot: () => {
          if (SaveSystem.load()) {
            TerminalSystem.log("REBOOTING FROM LAST SAVE...", "safe");
            UISystem.toggleMenu();
            setTimeout(() => location.reload(), 500);
            document
              .getElementById("pause-overlay")
              .classList.remove("visible");
          } else {
            location.reload();
          }
        },
      };

      const ObjectiveSystem = {
        wrapper: document.getElementById("objective-wrapper"),
        summary: document.getElementById("obj-summary"),
        title: document.getElementById("obj-phase-title"),
        list: document.getElementById("obj-task-list"),
        dot: document.getElementById("obj-pulse-dot"),

        currentPhaseIndex: 0,
        expanded: false,
        phases: [
          {
            name: "INITIALIZATION",
            tasks: [
              {
                id: "data",
                text: "Gather 100 Data",
                check: () => State.player.data >= 100,
              },
              {
                id: "compile",
                text: "Unlock Profiles (sys.compile)",
                check: () => State.player.combatUnlocked,
              },
              {
                id: "light",
                text: "Boost Light (sys.lumos)",
                check: () => State.player.lightLevel > 1.0,
              },
              {
                id: "def",
                text: "Add Protection (Shield/Cloak)",
                check: () => State.player.shield > 0 || State.player.cloaked,
              },
            ],
            complete: false,
          },
          {
            name: "EXTERMINATION",
            tasks: [
              {
                id: "k5",
                text: "Eliminate 5 Anomalies",
                check: () => State.game.killCount >= 5,
              },
              {
                id: "k10",
                text: "Eliminate 10 Anomalies",
                check: () => State.game.killCount >= 10,
              },
              {
                id: "k20",
                text: "Eliminate 20 Anomalies",
                check: () => State.game.killCount >= 20,
              },
            ],
            complete: false,
          },
          {
            name: "SURVIVAL",
            tasks: [
              {
                id: "dist",
                text: "Maintain Distance from Hostiles",
                check: () => State.game.survivalTimer > 600,
              },
              {
                id: "find",
                text: "Locate Safe Haven Signal",
                check: () => State.game.safeHaven !== null,
              },
              {
                id: "esc",
                text: "Enter Beacon & Evacuate",
                check: () => State.game.safeTimer > 0,
              },
            ],
            complete: false,
          },
        ],

        init: () => {
          ObjectiveSystem.render();
        },
        toggle: () => {
          ObjectiveSystem.expanded = !ObjectiveSystem.expanded;
          AudioSystem.playSFX("obj_toggle");
          if (ObjectiveSystem.expanded) {
            ObjectiveSystem.wrapper.classList.add("expanded");
            ObjectiveSystem.dot.classList.add("active");
          } else {
            ObjectiveSystem.wrapper.classList.remove("expanded");
            ObjectiveSystem.dot.classList.remove("active");
          }
        },
        collapse: () => {
          if (ObjectiveSystem.expanded) {
            ObjectiveSystem.expanded = false;
            ObjectiveSystem.wrapper.classList.remove("expanded");
            ObjectiveSystem.dot.classList.remove("active");
          }
        },
        notify: () => {
          AudioSystem.playSFX("obj_update");
          ObjectiveSystem.wrapper.classList.remove("pulse-anim");
          void ObjectiveSystem.wrapper.offsetWidth;
          ObjectiveSystem.wrapper.classList.add("pulse-anim");
          ObjectiveSystem.dot.classList.add("active");
        },
        update: () => {
          if (
            ObjectiveSystem.currentPhaseIndex >= ObjectiveSystem.phases.length
          )
            return;
          const phase =
            ObjectiveSystem.phases[ObjectiveSystem.currentPhaseIndex];
          let allDone = true;
          let changed = false;

          phase.tasks.forEach((t) => {
            if (!t.done) {
              if (t.check()) {
                t.done = true;
                changed = true;
                ObjectiveSystem.notify();
              } else {
                allDone = false;
              }
            }
          });

          if (changed) ObjectiveSystem.render();

          if (allDone && !phase.complete) {
            phase.complete = true;
            TerminalSystem.log(`PHASE COMPLETE: ${phase.name}`, "safe");
            ObjectiveSystem.notify();
            setTimeout(() => {
              ObjectiveSystem.currentPhaseIndex++;
              if (
                ObjectiveSystem.currentPhaseIndex <
                ObjectiveSystem.phases.length
              ) {
                TerminalSystem.log(
                  `NEW OBJECTIVE: ${
                    ObjectiveSystem.phases[ObjectiveSystem.currentPhaseIndex]
                      .name
                  }`
                );
                ObjectiveSystem.render();
              }
            }, 1500);
          }
        },
        render: () => {
          if (
            ObjectiveSystem.currentPhaseIndex >= ObjectiveSystem.phases.length
          ) {
            ObjectiveSystem.summary.innerText = "OBJ: MISSION COMPLETE";
            ObjectiveSystem.title.innerText = "ALL SYSTEMS GO";
            ObjectiveSystem.list.innerHTML = `<div class="task-item done"><span class="task-checkbox">[x]</span><span>Await Extraction</span></div>`;
            return;
          }
          const phase =
            ObjectiveSystem.phases[ObjectiveSystem.currentPhaseIndex];
          ObjectiveSystem.summary.innerText = `OBJ: ${phase.name}`;
          ObjectiveSystem.title.innerText = `PHASE ${
            ObjectiveSystem.currentPhaseIndex + 1
          }: ${phase.name}`;
          ObjectiveSystem.list.innerHTML = phase.tasks
            .map(
              (t) => `
                <div class="task-item ${t.done ? "done" : ""}">
                    <span class="task-checkbox">[${t.done ? "x" : " "}]</span>
                    <span>${t.text}</span>
                </div>
            `
            )
            .join("");
        },
      };

      const SpawnSystem = {
        generateChunk: (cx, cy) => {
          const key = `${cx},${cy}`;
          if (State.world.visitedChunks.has(key)) return;
          State.world.visitedChunks.add(key);
          const startX = cx * Config.chunkSize;
          const startY = cy * Config.chunkSize;
          for (let i = 0; i < 5; i++)
            SpawnSystem.spawnInChunk(startX, startY, "fragment");
          if (State.player.combatUnlocked) {
            for (let i = 0; i < 8; i++)
              SpawnSystem.spawnInChunk(startX, startY, "wall");
            if (Math.random() > 0.5)
              SpawnSystem.spawnEnemyInChunk(startX, startY);
          }
        },
        spawnInChunk: (cx, cy, type) => {
          for (let i = 0; i < 10; i++) {
            const x = cx + Math.random() * Config.chunkSize;
            const y = cy + Math.random() * Config.chunkSize;
            if (Utils.dist(x, y, 0, 0) < Config.safeZoneRadius) continue;
            let overlap = false;
            for (let s of State.world.structures)
              if (Utils.checkRectCollide(x, y, s)) overlap = true;
            if (!overlap) {
              if (type === "fragment")
                State.world.fragments.push({ x, y, size: 8, active: true });
              if (type === "wall")
                State.world.structures.push({
                  x,
                  y,
                  w: 40 + Math.random() * 100,
                  h: 40 + Math.random() * 100,
                });
              return;
            }
          }
        },
        spawnEnemyInChunk: (cx, cy) => {
          const x = cx + Math.random() * Config.chunkSize;
          const y = cy + Math.random() * Config.chunkSize;
          if (Utils.dist(x, y, State.player.x, State.player.y) < 500) return;
          let speed = 1.0 + State.game.killCount * 0.05;
          let hp = 3 + Math.floor(State.game.killCount / 2);
          State.world.enemies.push({
            x,
            y,
            targetX: x,
            targetY: y,
            angle: 0,
            speed,
            hp,
            cooldown: 0,
            sightRange: 450 + State.game.killCount * 20,
            wanderTimer: 0,
          });
        },
        spawnEnemyRing: () => {
          let count = State.game.killCount > 5 ? 3 : 1;
          for (let k = 0; k < count; k++) {
            for (let i = 0; i < 50; i++) {
              const angle = Math.random() * Math.PI * 2;
              const dist = 600 + Math.random() * 600;
              const x = State.player.x + Math.cos(angle) * dist;
              const y = State.player.y + Math.sin(angle) * dist;
              let overlap = false;
              for (let s of State.world.structures)
                if (Utils.checkRectCollide(x, y, s)) overlap = true;
              if (!overlap) {
                let speed = 1.0 + State.game.killCount * 0.05;
                let hp = 3 + Math.floor(State.game.killCount / 2);
                State.world.enemies.push({
                  x,
                  y,
                  targetX: x,
                  targetY: y,
                  angle: 0,
                  speed,
                  hp,
                  cooldown: 0,
                  sightRange: 450 + State.game.killCount * 20,
                  wanderTimer: 0,
                });
                break;
              }
            }
          }
        },
        spawnSafeHaven: () => {
          const offsetX =
            (Math.random() > 0.5 ? 1 : -1) * (1500 + Math.random() * 500);
          const offsetY =
            (Math.random() > 0.5 ? 1 : -1) * (1500 + Math.random() * 500);
          const x = Math.floor(State.player.x + offsetX);
          const y = Math.floor(State.player.y + offsetY);
          State.game.safeHaven = { x, y, r: 80, active: true };
          TerminalSystem.log("SIGNAL DETECTED: SAFE HAVEN", "safe");
          TerminalSystem.log(`COORDINATES: [${x}, ${y}]`, "safe");
          State.world.structures = State.world.structures.filter(
            (s) => Utils.dist(s.x, s.y, x, y) > 200
          );
          for (let i = 0; i < 10; i++) SpawnSystem.spawnEnemyRing();
        },
      };

      const TerminalSystem = {
        init: () => {
          TerminalSystem.updateHotbar();
          
          // These lines go to the Green Terminal Box (Internal)
          TerminalSystem.print("SYSTEM: NULL SECTOR", "#fff");
          TerminalSystem.print("Type /help for commands.", "#888");

          // --- SYSTEM LOG UPDATES (Top-Left HUD) ---
          // These appear in the game world log, NOT the terminal box.
          setTimeout(() => TerminalSystem.log('Use "WASD" Keys for movement'), 500);
          setTimeout(() => TerminalSystem.log('Press "Tab" key to open Terminal'), 1500);
          setTimeout(() => TerminalSystem.log('Press "Q" to view Objective'), 2500);
        },
        toggle: () => {
          State.player.isTerminalOpen = !State.player.isTerminalOpen;
          document.getElementById("terminal-wrapper").classList.toggle("open");
          if (State.player.isTerminalOpen) {
              AudioSystem.playSFX('term_open');
              setTimeout(() => document.getElementById("term-input").focus(), 50);
              ObjectiveSystem.collapse();
          } else {
              AudioSystem.playSFX('term_close');
              document.getElementById("term-input").blur();
          }
        },
        updateHotbar: () => {
          for (let i = 1; i <= 5; i++) document.getElementById(`slot-${i}`).innerText = State.hotbar[i] || "";
        },
        // Prints to the Green Box
        print: (msg, color, type = "msg") => {
          const d = document.createElement("div");
          d.className = `term-${type}`;
          d.style.color = color;
          d.innerText = msg;
          document.getElementById("term-output").appendChild(d);
          const out = document.getElementById("term-output");
          out.scrollTop = out.scrollHeight;
        },
        // Prints to the Top-Left HUD System Log
        log: (msg, type = "new") => {
          AudioSystem.playSFX('log');
          const l = document.getElementById("system-log");
          const d = document.createElement("div");
          d.className = `log-entry ${type}`;
          d.innerText = "> " + msg;
          l.appendChild(d);
          if (l.children.length > 6) l.removeChild(l.firstChild);
          setTimeout(() => d.classList.remove(type), 3000);
        },
        execute: (raw) => {
          const parts = raw.split(" ");
          const cmdKey = parts[0];
          const args = parts.slice(1);

          if (cmdKey === "/help") {
            TerminalSystem.print("--- SYSTEM COMMANDS ---", "#fff");
            for (const [key, val] of Object.entries(CommandBank)) {
              if (!val.req || (val.req === "combat" && State.player.combatUnlocked) || (val.req === "light_2" && State.player.lightLevel > 1.3)) {
                TerminalSystem.print(`${key} [${val.desc}] - ${val.cost} MB`, "#ccc");
              }
            }
            TerminalSystem.print("--- UTILITY ---", "#fff");
            TerminalSystem.print("/bind [key] [cmd] (Assign to Hotbar)", "#888");
            TerminalSystem.print("/cls (Clear Screen)", "#888");
            return;
          }
          if (cmdKey === "/cls") {
            document.getElementById("term-output").innerHTML = "";
            TerminalSystem.print("SYSTEM: CLEARED", "#fff");
            return;
          }
          if (cmdKey === "/bind") {
            const key = args[0];
            const commandToBind = args[1];
            if (["1", "2", "3", "4", "5"].includes(key)) {
              if (CommandBank[commandToBind]) {
                State.hotbar[key] = commandToBind;
                TerminalSystem.updateHotbar();
                TerminalSystem.print(`SUCCESS: Bound ${commandToBind} to [${key}]`, "#00ffaa");
              } else { TerminalSystem.print(`ERR: Command '${commandToBind}' not found`, "#ff3333"); }
            } else TerminalSystem.print("ERR: Invalid Key (Use 1-5)", "#ff3333");
            return;
          }

          const cmdData = CommandBank[cmdKey];
          if (!cmdData) { TerminalSystem.print(`ERR: UNKNOWN COMMAND '${cmdKey}'`, "#ff3333"); return; }
          if (cmdData.req === "combat" && !State.player.combatUnlocked) return TerminalSystem.print("ERR: COMBAT MODULE NOT FOUND", "#ff3333");
          if (cmdData.req === "light_2" && State.player.lightLevel < 1.3) return TerminalSystem.print("ERR: LIGHT LEVEL TOO LOW", "#ff3333");
          if (State.player.data < cmdData.cost) return TerminalSystem.print(`ERR: NEED ${cmdData.cost} MB DATA`, "#ff3333");
          
          if (cmdData.limit) {
            if (cmdKey === "sys.speed" && State.player.stats.speedLevel >= cmdData.limit) return TerminalSystem.print("ERR: MAX SPEED REACHED", "#ff3333");
            if (cmdKey === "sys.fire" && State.player.stats.fireRateLevel >= cmdData.limit) return TerminalSystem.print("ERR: MAX FIRE RATE REACHED", "#ff3333");
            if (cmdKey === "sys.protect" && State.player.shield > 0) return TerminalSystem.print("ERR: SHIELD ALREADY ACTIVE", "#ff3333");
          }

          State.player.data -= cmdData.cost;
          TerminalSystem.print(`EXEC: ${cmdKey}... OK`, "#00ffaa");
          AudioSystem.playSFX('term_success');

          switch (cmdData.action) {
            case "scan": State.player.scanActive = true; State.player.scanTimer = 600; TerminalSystem.log("SCAN COMPLETE"); break;
            case "light": 
                if (State.player.lightLevel < Config.maxLightLevel) { State.player.lightLevel += 0.2; TerminalSystem.log("LIGHT UPGRADED"); }
                else TerminalSystem.print("ERR: MAX LIGHT", "#f33"); break;
            case "combat":
                if (!State.player.combatUnlocked) { State.player.combatUnlocked = true; TerminalSystem.log("COMBAT UNLOCKED"); setTimeout(GameLogic.triggerCombatEvent, 1000); }
                else TerminalSystem.print("ERR: ALREADY ACTIVE", "#f33"); break;
            case "cloak": State.player.cloaked = true; State.player.cloakTimer = 300; TerminalSystem.log("CLOAK ENGAGED"); break;
            case "heal": State.player.health = Math.min(100, State.player.health + 50); TerminalSystem.log("HULL REPAIRED"); break;
            case "speed": State.player.stats.speedLevel++; Config.player.maxSpeed += 1; Config.player.accel += 0.05; TerminalSystem.log("VELOCITY INCREASED"); break;
            case "firerate": State.player.stats.fireRateLevel++; TerminalSystem.log("WEAPON OVERCLOCKED"); break;
            case "shield": State.player.shield = 50; TerminalSystem.log("SHIELD GENERATED"); break;
            case "unbind": if (args[0] && State.hotbar[args[0]]) { State.hotbar[args[0]] = null; TerminalSystem.updateHotbar(); TerminalSystem.print(`UNBOUND KEY [${args[0]}]`, "#0ff"); } break;
          }
        },
      };

      const InputSystem = {
        init: () => {
          window.addEventListener("resize", () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
          });
          window.addEventListener("keydown", (e) => {
            // Audio unlock on first interaction
            AudioSystem.init();

            if (e.key === "Escape") {
              UISystem.toggleMenu();
              return;
            }
            if (
              State.player.isTerminalOpen &&
              e.key !== "Tab" &&
              e.key !== "Enter"
            )
              return;

            // Objective Toggle - Q
            if (e.key.toLowerCase() === "q") {
              ObjectiveSystem.toggle();
              return;
            }

            // Movement Auto-Collapse
            if (
              ["w", "a", "s", "d"].includes(e.key.toLowerCase()) &&
              ObjectiveSystem.expanded
            ) {
              ObjectiveSystem.collapse();
            }

            if (e.key === "Tab") {
              e.preventDefault();
              TerminalSystem.toggle();
              return;
            }
            if (e.key.toLowerCase() === "x") {
              if (State.player.combatUnlocked) GameLogic.toggleProfile();
              else TerminalSystem.log("ERR: COMBAT MODULE MISSING", "error");
            }
            if (
              State.input.keys[e.key] !== undefined &&
              !State.player.isTerminalOpen
            )
              State.input.keys[e.key] = true;
            if (
              ["1", "2", "3", "4", "5"].includes(e.key) &&
              State.hotbar[e.key]
            )
              TerminalSystem.execute(State.hotbar[e.key]);
            if (e.key === "Enter" && State.player.isTerminalOpen) {
              const val = document.getElementById("term-input").value.trim();
              if (val) {
                TerminalSystem.print("> " + val, "#888", "cmd");
                TerminalSystem.execute(val);
                document.getElementById("term-input").value = "";
              }
            }
          });
          window.addEventListener("keyup", (e) => {
            if (State.input.keys[e.key] !== undefined)
              State.input.keys[e.key] = false;
          });
          window.addEventListener("mousedown", (e) => {
            AudioSystem.init(); // Init Audio on click too
            if (
              State.player.mode === "combat" &&
              !State.player.isDead &&
              State.player.combatUnlocked &&
              !State.game.paused
            )
              GameLogic.spawnPlayerProjectile(e.clientX, e.clientY);
          });
        },
      };

      const GameLogic = {
        init: async () => {
          // AudioSystem init happens on user interaction (InputSystem), not here

          const savedData = localStorage.getItem("0110_save");
          if (savedData && !localStorage.getItem("0110_save_v2")) {
            const parsed = JSON.parse(savedData);
            State.player.data = parseInt(parsed.data) || 0;
            State.player.lightLevel = parseFloat(parsed.lightLevel) || 1.0;
          }
          State.player.mode = "roam";
          document.body.className = "mode-roam";
          GameLogic.checkChunks();
          ObjectiveSystem.init();

          // CINEMATIC SEQUENCE
          await Utils.wait(500);
          AudioSystem.playSFX("intro_hit");
          document.getElementById("intro-title").style.opacity = 1;
          document.getElementById("intro-sub").style.opacity = 1;
          await Utils.wait(2500);
          document.getElementById("intro-title").style.opacity = 0;
          document.getElementById("intro-sub").style.opacity = 0;
          await Utils.wait(1000);
          document.getElementById("cinematic-overlay").style.opacity = 0;

          // Story Overlay
          AudioSystem.playSFX("story_ambience");
          document.getElementById("story-overlay").style.opacity = 1;
          await Utils.wait(20000); // Read time
          document.getElementById("story-overlay").style.opacity = 0;
          await Utils.wait(1000);

          document.getElementById("ui-layer").classList.add("active");
          TerminalSystem.init();
        },
        checkChunks: () => {
          const cx = Math.floor(State.player.x / Config.chunkSize);
          const cy = Math.floor(State.player.y / Config.chunkSize);
          for (
            let x = -Config.renderDistance;
            x <= Config.renderDistance;
            x++
          ) {
            for (
              let y = -Config.renderDistance;
              y <= Config.renderDistance;
              y++
            ) {
              SpawnSystem.generateChunk(cx + x, cy + y);
            }
          }
        },
        triggerCombatEvent: () => {
          TerminalSystem.print("WARNING: ARCHITECTURE RE-WRITTEN", "#ff3333");
          TerminalSystem.print(">> HOSTILES DETECTED", "#ff3333");
          document
            .getElementById("profile-indicator")
            .classList.remove("hidden");
          TerminalSystem.log("PRESS 'X' FOR COMBAT MODE");
          State.world.visitedChunks.forEach((key) => {
            const [cx, cy] = key.split(",").map(Number);
            const sx = cx * Config.chunkSize;
            const sy = cy * Config.chunkSize;
            for (let i = 0; i < 8; i++)
              SpawnSystem.spawnInChunk(sx, sy, "wall");
          });
          for (let i = 0; i < 4; i++) SpawnSystem.spawnEnemyRing();
        },
        toggleProfile: () => {
          if (State.player.isTerminalOpen) return;
          if (State.player.mode === "roam") {
            State.player.mode = "combat";
            document.body.className = "mode-combat";
            document.getElementById("profile-indicator").innerText =
              "PROFILE: ATTACK/DEFENSE";
            TerminalSystem.log("COMBAT PROFILE ENGAGED");
          } else {
            State.player.mode = "roam";
            document.body.className = "mode-roam";
            document.getElementById("profile-indicator").innerText =
              "PROFILE: ROAMING";
            TerminalSystem.log("ROAMING PROFILE");
          }
        },
        spawnPlayerProjectile: (mouseX, mouseY) => {
          if (Number(State.player.data) >= Config.combat.bulletCost) {
            State.player.data -= Config.combat.bulletCost;
            const rect = canvas.getBoundingClientRect();
            const angle = Math.atan2(
              mouseY - rect.top - canvas.height / 2,
              mouseX - rect.left - canvas.width / 2
            );
            State.world.projectiles.push({
              x: State.player.x,
              y: State.player.y,
              vx: Math.cos(angle) * Config.combat.bulletSpeed,
              vy: Math.sin(angle) * Config.combat.bulletSpeed,
              type: "player",
              life: 100,
            });
          } else TerminalSystem.log("ERR: NO DATA", "error");
        },
        update: () => {
          if (State.player.isDead || State.game.paused) return;

          const timeScale = State.player.isTerminalOpen ? 0.1 : 1.0;
          let speedMod = State.player.mode === "combat" ? 0.7 : 1.0;

          // Physics
          if (State.input.keys.w)
            State.player.vy -= Config.player.accel * timeScale * speedMod;
          if (State.input.keys.s)
            State.player.vy += Config.player.accel * timeScale * speedMod;
          if (State.input.keys.a)
            State.player.vx -= Config.player.accel * timeScale * speedMod;
          if (State.input.keys.d)
            State.player.vx += Config.player.accel * timeScale * speedMod;

          let currentMax = Config.player.maxSpeed;
          if (Math.abs(State.player.vx) > currentMax) State.player.vx *= 0.9;
          if (Math.abs(State.player.vy) > currentMax) State.player.vy *= 0.9;
          State.player.vx *= Config.player.friction;
          State.player.vy *= Config.player.friction;
          let nextX = State.player.x + State.player.vx * timeScale;
          let nextY = State.player.y + State.player.vy * timeScale;

          for (let s of State.world.structures) {
            if (Utils.checkRectCollide(nextX, State.player.y, s)) {
              State.player.vx *= -0.5;
              nextX = State.player.x;
            }
            if (Utils.checkRectCollide(nextX, nextY, s)) {
              State.player.vy *= -0.5;
              nextY = State.player.y;
            }
          }
          State.player.x = nextX;
          State.player.y = nextY;

          GameLogic.checkChunks();
          ObjectiveSystem.update();

          if (
            State.player.combatUnlocked &&
            State.world.enemies.length < 5 + State.game.killCount / 3
          ) {
            if (Math.random() < 0.01) SpawnSystem.spawnEnemyRing();
          }

          if (
            ObjectiveSystem.currentPhaseIndex === 2 &&
            !State.game.safeHaven
          ) {
            let enemiesNearby = State.world.enemies.some(
              (e) => Utils.dist(State.player.x, State.player.y, e.x, e.y) < 600
            );
            let tooClose = State.world.enemies.some(
              (e) => Utils.dist(State.player.x, State.player.y, e.x, e.y) < 250
            );
            if (enemiesNearby && !tooClose) State.game.survivalTimer++;
            if (State.game.survivalTimer > 600) SpawnSystem.spawnSafeHaven();
          }

          if (State.game.safeHaven) {
            const h = State.game.safeHaven;
            if (Utils.dist(State.player.x, State.player.y, h.x, h.y) < h.r) {
              State.game.safeTimer++;
              if (State.game.safeTimer > 180) {
                document.getElementById("fade-overlay").style.opacity = 1;
                TerminalSystem.print(
                  ">> SIGNAL LOCK. TRANSPORTING...",
                  "#00ffaa"
                );
                setTimeout(() => (window.location.href = "end.html"), 3000);
              }
            } else State.game.safeTimer = 0;
          }

          State.world.fragments.forEach((f) => {
            if (
              f.active &&
              Utils.dist(State.player.x, State.player.y, f.x, f.y) < 20
            ) {
              f.active = false;
              State.player.data += 10;
              TerminalSystem.log("DATA: +10 MB");
            }
          });
          if (State.world.fragments.filter((f) => f.active).length < 20)
            SpawnSystem.spawnInChunk(
              State.player.x,
              State.player.y,
              "fragment"
            );

          if (State.player.cloaked)
            if (--State.player.cloakTimer <= 0) State.player.cloaked = false;
          if (State.player.scanActive) State.player.scanTimer--;

          if (timeScale > 0 && State.player.combatUnlocked) {
            GameLogic.updateEnemies(timeScale);
            GameLogic.updateProjectiles(timeScale);
          }
        },
        updateEnemies: (dt) => {
          State.world.enemies.forEach((en, index) => {
            let sepX = 0,
              sepY = 0;
            // STRONG SEPARATION LOGIC
            State.world.enemies.forEach((other, otherIdx) => {
              if (index !== otherIdx) {
                let d = Utils.dist(en.x, en.y, other.x, other.y);
                if (d < 60) {
                  // Increased separation radius
                  sepX += (en.x - other.x) * 1.5;
                  sepY += (en.y - other.y) * 1.5;
                }
              }
            });
            if (en.cooldown > 0) en.cooldown -= dt;
            let dist = Utils.dist(en.x, en.y, State.player.x, State.player.y);
            let hit = Utils.rayCast(en.x, en.y, State.player.x, State.player.y);

            // WANDER LOGIC
            if (dist > 700 || hit.hit) {
              // If far away or blocked, pick a random point nearby to move to
              if (en.wanderTimer <= 0) {
                en.targetX = en.x + (Math.random() - 0.5) * 400;
                en.targetY = en.y + (Math.random() - 0.5) * 400;
                en.wanderTimer = 100 + Math.random() * 100;
              }
              en.wanderTimer -= dt;
            } else if (
              State.game.killCount > 10 ||
              (dist < en.sightRange && !hit.hit && !State.player.cloaked)
            ) {
              // Chase
              en.targetX = State.player.x;
              en.targetY = State.player.y;
            }

            let dx = en.targetX - en.x;
            let dy = en.targetY - en.y;
            let moveDist = Math.sqrt(dx * dx + dy * dy);

            if (moveDist > 10) {
              let nextX = en.x + (dx / moveDist) * en.speed * dt + sepX * 0.1;
              let nextY = en.y + (dy / moveDist) * en.speed * dt + sepY * 0.1;
              let blocked = false;
              for (let s of State.world.structures)
                if (Utils.checkRectCollide(nextX, nextY, s)) blocked = true;
              if (!blocked) {
                en.x = nextX;
                en.y = nextY;
                en.angle = Math.atan2(dy, dx);
              } else {
                if (
                  !Utils.checkRectCollide(
                    nextX,
                    en.y,
                    State.world.structures[0]
                  )
                )
                  en.x = nextX;
                else if (
                  !Utils.checkRectCollide(
                    en.x,
                    nextY,
                    State.world.structures[0]
                  )
                )
                  en.y = nextY;
                else {
                  en.targetX = en.x + (Math.random() - 0.5) * 200;
                  en.targetY = en.y + (Math.random() - 0.5) * 200;
                }
              }
            }

            if (dist < en.sightRange && !hit.hit && !State.player.cloaked) {
              en.angle = Math.atan2(
                State.player.y - en.y,
                State.player.x - en.x
              );
              if (en.cooldown <= 0) {
                State.world.projectiles.push({
                  x: en.x,
                  y: en.y,
                  vx: Math.cos(en.angle) * 6,
                  vy: Math.sin(en.angle) * 6,
                  type: "enemy",
                  life: 100,
                });
                en.cooldown = Math.max(20, 60 - State.game.killCount * 2);
              }
            }
          });
        },
        updateProjectiles: (dt) => {
          for (let i = State.world.projectiles.length - 1; i >= 0; i--) {
            let p = State.world.projectiles[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.life -= dt;
            let hitWall = false;
            for (let s of State.world.structures)
              if (Utils.checkRectCollide(p.x, p.y, s)) hitWall = true;
            if (hitWall || p.life <= 0) {
              State.world.projectiles.splice(i, 1);
              continue;
            }
            if (p.type === "enemy") {
              if (
                Utils.dist(p.x, p.y, State.player.x, State.player.y) <
                State.player.size + 5
              ) {
                let inSafeHaven = false;
                if (State.game.safeHaven) {
                  if (
                    Utils.dist(
                      State.player.x,
                      State.player.y,
                      State.game.safeHaven.x,
                      State.game.safeHaven.y
                    ) < State.game.safeHaven.r
                  ) {
                    inSafeHaven = true;
                  }
                }
                if (!inSafeHaven) {
                  if (State.player.shield > 0) {
                    State.player.shield -= 10;
                    TerminalSystem.log("SHIELD ABSORB", "safe");
                  } else {
                    State.player.health -= 10;
                    TerminalSystem.log("HULL DAMAGE", "error");
                  }
                  if (State.player.health <= 0) GameLogic.killPlayer();
                }
                State.world.projectiles.splice(i, 1);
                continue;
              }
            }
            if (p.type === "player") {
              for (let j = State.world.enemies.length - 1; j >= 0; j--) {
                let e = State.world.enemies[j];
                if (Utils.dist(p.x, p.y, e.x, e.y) < 15) {
                  e.hp--;
                  State.world.projectiles.splice(i, 1);
                  if (e.hp <= 0) {
                    State.world.enemies.splice(j, 1);
                    State.player.data += 50;
                    State.game.killCount++;
                    TerminalSystem.log(
                      `ENEMY ELIMINATED [${State.game.killCount}]`
                    );
                  }
                  break;
                }
              }
            }
          }
        },
        killPlayer: () => {
          State.player.isDead = true;
          document.getElementById("overlay-screen").style.opacity = 1;
          setTimeout(() => location.reload(), 3000);
        },
      };

      const RenderSystem = {
        draw: () => {
          ctx.fillStyle = "#050505";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          const cx = canvas.width / 2,
            cy = canvas.height / 2;
          ctx.save();
          ctx.translate(cx - State.player.x, cy - State.player.y);

          ctx.strokeStyle = Config.colors.grid;
          ctx.lineWidth = 1;
          ctx.beginPath();
          const sc = Math.floor((State.player.x - cx) / Config.gridSize),
            ec = Math.floor((State.player.x + cx) / Config.gridSize) + 1;
          const sr = Math.floor((State.player.y - cy) / Config.gridSize),
            er = Math.floor((State.player.y + cy) / Config.gridSize) + 1;
          for (
            let x = sc * Config.gridSize;
            x <= ec * Config.gridSize;
            x += Config.gridSize
          ) {
            ctx.moveTo(x, State.player.y - cy);
            ctx.lineTo(x, State.player.y + cy);
          }
          for (
            let y = sr * Config.gridSize;
            y <= er * Config.gridSize;
            y += Config.gridSize
          ) {
            ctx.moveTo(State.player.x - cx, y);
            ctx.lineTo(State.player.x + cx, y);
          }
          ctx.stroke();

          ctx.fillStyle = Config.colors.wall;
          State.world.structures.forEach((s) => {
            if (
              s.x + s.w > State.player.x - cx &&
              s.x < State.player.x + cx &&
              s.y + s.h > State.player.y - cy &&
              s.y < State.player.y + cy
            )
              ctx.fillRect(s.x, s.y, s.w, s.h);
          });

          ctx.fillStyle = Config.colors.fragment;
          ctx.shadowBlur = 10;
          ctx.shadowColor = Config.colors.fragment;
          State.world.fragments.forEach((f) => {
            if (
              f.active &&
              f.x > State.player.x - cx &&
              f.x < State.player.x + cx
            )
              ctx.fillRect(f.x - 4, f.y - 4, 8, 8);
          });
          ctx.shadowBlur = 0;

          State.world.enemies.forEach((en) => {
            if (
              en.x > State.player.x - cx - 1000 &&
              en.x < State.player.x + cx + 1000
            ) {
              ctx.fillStyle = "rgba(255, 50, 50, 0.1)";
              ctx.beginPath();
              ctx.moveTo(en.x, en.y);
              ctx.arc(
                en.x,
                en.y,
                en.sightRange,
                en.angle - 0.4,
                en.angle + 0.4
              );
              ctx.fill();
              ctx.fillStyle = Config.colors.enemy;
              ctx.save();
              ctx.translate(en.x, en.y);
              ctx.rotate(en.angle);
              ctx.beginPath();
              ctx.moveTo(10, 0);
              ctx.lineTo(-10, 8);
              ctx.lineTo(-10, -8);
              ctx.fill();
              ctx.restore();
            }
          });

          State.world.projectiles.forEach((p) => {
            ctx.fillStyle = p.type === "player" ? "#ff0" : "#f00";
            ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
          });

          if (State.game.safeHaven) {
            const h = State.game.safeHaven;
            let pulse = Math.sin(Date.now() / 200) * 5;
            ctx.strokeStyle = Config.colors.safe;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(h.x, h.y, h.r + pulse, 0, Math.PI * 2);
            ctx.stroke();
            if (State.game.safeTimer > 0) {
              ctx.fillStyle = "rgba(0, 255, 170, 0.2)";
              ctx.beginPath();
              ctx.arc(
                h.x,
                h.y,
                h.r * (State.game.safeTimer / 180),
                0,
                Math.PI * 2
              );
              ctx.fill();
            }
          }

          if (!State.player.isDead) {
            ctx.globalAlpha = State.player.cloaked ? 0.3 : 1.0;
            ctx.fillStyle = State.player.mode === "combat" ? "#fa0" : "#fff";
            ctx.shadowBlur = 10;
            ctx.shadowColor = ctx.fillStyle;
            ctx.beginPath();
            ctx.arc(State.player.x, State.player.y, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1.0;
            if (State.player.mode === "combat") {
              ctx.strokeStyle = "#ff3333";
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.arc(State.player.x, State.player.y, 20, 0, Math.PI * 2);
              ctx.stroke();
            }
          }
          ctx.restore();

          let healthMod = Math.max(0.3, State.player.health / 100);
          let r = Config.baseLightRadius * State.player.lightLevel * healthMod;
          let g = ctx.createRadialGradient(cx, cy, 10, cx, cy, r);
          g.addColorStop(0, "rgba(0,0,0,0)");
          g.addColorStop(1, "rgba(0,0,0,1)");
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          UISystem.update();
          RenderSystem.drawMiniMap();
        },
        drawMiniMap: () => {
          miniCtx.fillStyle = "#000";
          miniCtx.fillRect(0, 0, 140, 140);
          const s = 0.05,
            cx = 70,
            cy = 70;
          miniCtx.fillStyle = "#f33";
          State.world.enemies.forEach((e) => {
            let rx = (e.x - State.player.x) * s,
              ry = (e.y - State.player.y) * s;
            if (Math.abs(rx) < 70 && Math.abs(ry) < 70)
              miniCtx.fillRect(cx + rx - 1.5, cy + ry - 1.5, 3, 3);
          });
          if (State.game.safeHaven) {
            let h = State.game.safeHaven;
            let rx = (h.x - State.player.x) * s,
              ry = (h.y - State.player.y) * s;
            if (Math.abs(rx) < 70 && Math.abs(ry) < 70) {
              miniCtx.strokeStyle = Config.colors.safe;
              miniCtx.lineWidth = 2;
              miniCtx.beginPath();
              miniCtx.arc(cx + rx, cy + ry, h.r * s, 0, Math.PI * 2);
              miniCtx.stroke();
            }
          }
          miniCtx.fillStyle = "#444";
          State.world.structures.forEach((st) => {
            let rx = (st.x - State.player.x) * s,
              ry = (st.y - State.player.y) * s;
            if (Math.abs(rx) < 70 && Math.abs(ry) < 70)
              miniCtx.fillRect(cx + rx, cy + ry, st.w * s, st.h * s);
          });
          if (State.player.scanActive) {
            miniCtx.fillStyle = Config.colors.fragment;
            State.world.fragments.forEach((f) => {
              if (f.active) {
                let rx = (f.x - State.player.x) * s,
                  ry = (f.y - State.player.y) * s;
                if (Math.abs(rx) < 70 && Math.abs(ry) < 70)
                  miniCtx.fillRect(cx + rx, cy + ry, 2, 2);
              }
            });
          }
          miniCtx.fillStyle = State.player.mode === "combat" ? "#fa0" : "#fff";
          miniCtx.beginPath();
          miniCtx.arc(cx, cy, 2, 0, Math.PI * 2);
          miniCtx.fill();
        },
      };

      const UISystem = {
        update: () => {
          document.getElementById(
            "coords-display"
          ).innerText = `LOC: [${Math.floor(State.player.x)}, ${Math.floor(
            State.player.y
          )}]`;
          document.getElementById(
            "data-bank"
          ).innerText = `DATA: ${State.player.data} MB`;
          document.getElementById(
            "bar-health"
          ).style.width = `${State.player.health}%`;
          let totalLight = Math.floor(
            Config.baseLightRadius * State.player.lightLevel
          );
          document.getElementById("light-val").innerText = totalLight;
          if (State.player.shield > 0)
            document.getElementById("shield-label").classList.remove("hidden");
          else document.getElementById("shield-label").classList.add("hidden");
        },
        toggleMenu: () => {
          const menu = document.getElementById("menu-dropdown");
          const overlay = document.getElementById("pause-overlay");
          menu.classList.toggle("show");
          State.game.paused = !State.game.paused;

          if (State.game.paused) overlay.classList.add("visible");
          else overlay.classList.remove("visible");
        },
      };

      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      GameLogic.init();
      InputSystem.init();

      function loop() {
        GameLogic.update();
        RenderSystem.draw();
        requestAnimationFrame(loop);
      }
      loop();
    </script>
  </body>
</html>
